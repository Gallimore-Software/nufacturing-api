import { {{ eventHandlerName }} } from './eventHandler';
import { {{ serviceName }} } from '@application/services/{{ serviceName }}';
import { Logger } from '@infrastructure/logging/logger';
import { {{ eventContract }} } from '@domain/contracts/{{ eventContractName }}';

jest.mock('@application/services/{{ serviceName }}');
jest.mock('@infrastructure/logging/logger');

describe('{{ eventHandlerName }}', () => {
  let eventHandler: {{ eventHandlerName }};
  let serviceMock: jest.Mocked<{{ serviceName }}>;
  let loggerMock: jest.Mocked<Logger>;
  const mockEvent: {{ eventContract }} = {
    // TODO: Define the properties of the eventContract for mock
  };

  beforeEach(() => {
    serviceMock = new {{ serviceName }}() as jest.Mocked<{{ serviceName }}>;
    loggerMock = new Logger() as jest.Mocked<Logger>;

    eventHandler = new {{ eventHandlerName }}(serviceMock, loggerMock);
  });

  it('should call service.processEvent when handle is invoked', async () => {
    // Arrange
    serviceMock.processEvent.mockResolvedValueOnce(undefined);

    // Act
    await eventHandler.handle(mockEvent);

    // Assert
    expect(serviceMock.processEvent).toHaveBeenCalledWith(mockEvent);
    expect(loggerMock.info).toHaveBeenCalledWith(expect.stringContaining('Handling event'));
    expect(loggerMock.info).toHaveBeenCalledWith(expect.stringContaining('Successfully handled event'));
  });

  it('should log an error when service.processEvent fails', async () => {
    // Arrange
    const error = new Error('Service error');
    serviceMock.processEvent.mockRejectedValueOnce(error);

    // Act
    await eventHandler.handle(mockEvent).catch(() => {});

    // Assert
    expect(serviceMock.processEvent).toHaveBeenCalledWith(mockEvent);
    expect(loggerMock.error).toHaveBeenCalledWith(expect.stringContaining('Error while handling event'), error);
  });
});
